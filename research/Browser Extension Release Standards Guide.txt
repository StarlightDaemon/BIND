Best Practices for Browser Extension Release Engineering: A Comprehensive Standard for Torrent Control Reloaded
Executive Summary
The modernization of browser extensions—precipitated by the mandatory migration to Manifest V3 (MV3)—has fundamentally altered the operational landscape for extension developers. While the architectural shift from persistent background pages to ephemeral service workers addresses security and performance, it simultaneously introduces complexity into the release engineering lifecycle. For a project such as "Torrent Control Reloaded," which leverages a modern stack comprising React and TypeScript, the release process represents a critical intersection of code integrity, platform compliance, and user communication.
Unlike traditional web application deployments, which benefit from instantaneous atomic swaps and server-side control, browser extension releases function within a distributed, asynchronous environment. Code updates are subjected to opaque review queues in the Chrome Web Store (CWS) and Mozilla Add-ons (AMO) ecosystem, creating a temporal decoupling between the "release" event (tagging code in git) and the "deployment" event (user acquisition of the update). This latency necessitates a release engineering standard that is far more rigorous than typical SaaS protocols.
This report establishes a definitive "Best in Class" standard for versioning, changelog management, and release automation. It synthesizes technical constraints from Chromium and Mozilla documentation, industry-standard versioning philosophies (Semantic Versioning), and modern CI/CD practices. The objective is to provide an exhaustive blueprint that ensures "Torrent Control Reloaded" maintains semantic clarity for developers, regulatory compliance for store listings, and transparent communication for end-users.
________________
1. Version Numbering Strategy: Architecture and Compliance
The selection of a versioning scheme is not merely a stylistic choice; it is the fundamental protocol that governs update precedence, compatibility signaling, and user trust. In the browser extension ecosystem, this decision is uniquely constrained by the rigid schema definitions of extension manifests, which differ significantly from the flexible tagging systems found in standard npm or Docker registries.
1.1 Comparative Analysis: Semantic Versioning vs. Calendar Versioning
To determine the optimal strategy for "Torrent Control Reloaded," we must evaluate the two dominant paradigms in software release identification: Semantic Versioning (SemVer) and Calendar Versioning (CalVer). Each system encodes different information about the software lifecycle and offers distinct advantages depending on the nature of the development velocity.
1.1.1 Semantic Versioning (SemVer)
Semantic Versioning follows the strict format MAJOR.MINOR.PATCH (e.g., 2.1.4). This system encodes the nature of the change rather than the time of the change.
* MAJOR: Signals incompatible API changes or significant shifts in functionality that may require user intervention or re-learning.
* MINOR: Indicates functionality added in a backward-compatible manner.
* PATCH: Denotes backward-compatible bug fixes.1
Strategic Advantage for Extensions:
The primary argument for SemVer in the context of "Torrent Control Reloaded" is the alignment with the React/TypeScript ecosystem. The project's internal dependencies are managed via package.json, which inherently utilizes SemVer for dependency resolution. By aligning the external artifact version (the extension build) with the internal package version, the engineering team maintains a unified mental model of the software state.2
Furthermore, SemVer provides a crucial communication channel regarding risk. A jump from 1.4.0 to 2.0.0 signals to the user (and the store reviewer) that the extension has undergone a fundamental transformation—perhaps a UI overhaul or a migration to a new Torrent client API. Conversely, a shift from 1.4.1 to 1.4.2 implies a low-risk, maintenance-focused update that users can accept passively.3
Challenges in the Extension Context:
The "Semantic Gap" is the primary weakness of SemVer for extensions. Strictly speaking, extensions rarely define public-facing APIs consumed by other software. Therefore, the definition of "Breaking Change" (Major) becomes subjective. Does removing a "Dark Mode" toggle constitute a breaking change? Does migrating from chrome.webRequest to declarativeNetRequest (MV2 to MV3) count as Major? Without strict API consumers, SemVer relies on the discipline of the release engineer to categorize impact accurately.2
1.1.2 Calendar Versioning (CalVer)
CalVer relies on the temporal point of release, often formatted as YYYY.MM.PATCH or YY.MM.DD (e.g., 2025.04.1).
Strategic Advantage for Extensions:
CalVer is increasingly popular for "evergreen" products where the exact feature set is less important than the "freshness" of the build. For security-focused extensions (like password managers or ad blockers), a version number like 2025.11.0 serves as a trust signal, assuring the user that the software includes the latest definition lists or security patches.4 It also eliminates the friction of deciding whether a release is "Major" or "Minor"—if it is released in November 2025, the version is determined automatically.5
Critical Flaw in the Store Ecosystem:
The fatal flaw of CalVer for extensions lies in the review latency. If a release is built and tagged on 2025.10.31 (October 31st), it may sit in the Chrome Web Store review queue for several weeks, potentially launching in mid-November. By the time the user receives the update, the version number 2025.10.31 appears outdated, creating a psychological dissonance. Unlike SaaS apps where deployment is instant, extension versions can become "stale" before they even go live.
1.1.3 The Verdict for Torrent Control Reloaded
Recommendation: Semantic Versioning (SemVer) with Strict Compliance.
For a functional utility like "Torrent Control Reloaded," features are the primary driver of value, not merely "freshness." Users are interested in whether support for a new client (e.g., qBittorrent v5.0) has been added (a MINOR change) or if a bug preventing connection has been fixed (a PATCH). SemVer communicates this effectively. CalVer is rejected for this project due to the review latency issue and the lack of alignment with the feature-driven development cycle typical of React applications.3
1.2 Platform-Specific Constraints and the "Version Name" Architecture
While SemVer is the logical choice, implementing it requires navigating the specific validation rules of the browser manifests. The Chrome Web Store (CWS) and Mozilla Add-ons (AMO) have divergent requirements that necessitate a sophisticated build-time version translation strategy.
1.2.1 The Chrome Integer Constraint
Chrome’s manifest.json version field is notoriously restrictive. It accepts a string composed of one to four dot-separated integers (e.g., 1, 1.2, 1.2.3, 1.2.3.4). Crucially, the schema validation rejects any non-numeric characters.6
* Invalid in Chrome: 1.0.0-beta, 2.0.0-rc1, 1.0.0-alpha.5
* Valid in Chrome: 1.0.0.1, 2.1.0
This constraint breaks standard SemVer tooling, which often relies on pre-release tags (hyphens and strings) to denote alpha/beta states. If the package.json version is set to 1.2.0-beta.1 and blindly copied to manifest.json during the build, the Chrome Web Store upload will fail validation.
1.2.2 The Firefox Flexibility
Conversely, Firefox (AMO) allows a much richer set of version strings, supporting standard SemVer formats including alpha, beta, pre, and rc. Firefox parses 1.0.0b1 as semantically older than 1.0.0, aligning perfectly with standard release flows.7
1.2.3 The "Version Name" Strategy (Manifest V3)
To reconcile these differences, we must leverage the version_name field available in Manifest V3. This field is distinct from version.
* version: Used strictly by the browser's update engine to determine precedence. Must be integers in Chrome.
* version_name: Used strictly for display in the extension management UI (chrome://extensions) and the store listing. It accepts strings.
The Hybrid Strategy:
The release pipeline must perform a transformation. For stable releases, version and version_name are identical. For pre-releases, they diverge to satisfy both the machine (update engine) and the human (tester).
Release Type
	package.json (Source)
	Chrome version (Update Logic)
	Chrome version_name (Display)
	Firefox version
	Stable
	1.2.0
	1.2.0
	1.2.0
	1.2.0
	Beta
	1.2.0-beta.1
	1.2.0.1
	1.2.0 Beta 1
	1.2.0b1
	Release Candidate
	1.2.0-rc.3
	1.2.0.3
	1.2.0 RC 3
	1.2.0rc3
	Table 1: Matrix of version transformations across platforms.6
1.3 Increment Strategy: Major, Minor, and Patch
In the absence of a public API, "Torrent Control Reloaded" must define its own semantic rules for version increments. This definition ensures consistency across the team and sets user expectations.
1.3.1 Major Increments (1.0.0 -> 2.0.0)
A MAJOR version should be triggered by "Breaking Changes" from the perspective of the user experience or the platform permissions.
* Permission Scope Expansion: If an update requires a new permission that triggers a browser warning (e.g., adding management or tabs permission), the extension is automatically disabled by the browser until the user re-approves it. This is a catastrophic "breaking change" for user retention. It warrants a Major version bump and significant communication.1
* Architectural Overhaul: Moving from Manifest V2 to V3 is a Major change, as it fundamentally alters the background persistence model (Persistent Page -> Service Worker), potentially affecting connection stability with torrent clients.11
* Feature Removal: If a core feature (e.g., "Auto-add torrents") is removed due to policy changes or technical limitations, this constitutes a breaking change for users relying on that workflow.
1.3.2 Minor Increments (1.1.0 -> 1.2.0)
A MINOR version is appropriate for significant new capabilities that are backward compatible.
* New Client Support: Adding support for a new backend (e.g., Transmission, Deluge) when only qBittorrent was supported previously.
* UI Features: Introducing "Dark Mode," a new "Speed Graph," or "Context Menu" integrations.
* Performance: Significant optimizations that do not alter the feature set but noticeably improve the user experience (e.g., virtualized lists for handling 10,000+ torrents).
1.3.3 Patch Increments (1.1.0 -> 1.1.1)
A PATCH version is reserved for safe, invisible changes.
* Bug Fixes: resolving UI rendering glitches, fixing typos in locale files, or patching logic errors in the connection retry mechanism.
* Security Patches: Updating vulnerable npm dependencies (e.g., lodash prototype pollution fix).
* Internal Refactoring: Code cleanup that yields no visible change to the user (e.g., converting a class component to a functional React hook).
1.4 Pre-release Strategy for Stores
Submitting pre-release versions (Alpha/Beta) to the public store listing is widely considered an anti-pattern in the extension ecosystem. It confuses the algorithm and the user base. Instead, a "Trusted Tester" pipeline should be established.
Chrome Web Store Strategy:
Chrome provides a "Trusted Testers" mechanism. However, publishing a beta version to the same Extension ID as the production version is risky because you cannot easily "rollback" a version number if a bug is found.
* Recommendation: Maintain two distinct Extension IDs:
   1. Torrent Control Reloaded (Prod): Public visibility.
   2. Torrent Control Reloaded (Beta): Private visibility, restricted to a Google Group of testers. This allows you to push 1.3.0.4 (Beta) to the Beta ID without affecting the Prod ID. Once validated, the code is tagged 1.3.0 and pushed to the Prod ID.9
Firefox (AMO) Strategy:
Firefox allows "Self-Distributed" (unlisted) versions.
* Recommendation: For Beta builds, use the web-ext sign command to generate a signed .xpi file that is not listed on AMO. Distribute this .xpi file via GitHub Releases to users who want to opt-in to testing. This keeps the public AMO listing clean while allowing power users to side-load the signed beta easily.7
________________
2. Changelogs: The "Gold Standard" for Documentation
The changelog is the historical record of the project's evolution. In the open-source and extension communities, a well-maintained changelog is a primary indicator of project health and maintainer discipline. For "Torrent Control Reloaded," the changelog serves distinct audiences: the developers debugging regressions, and the users evaluating new features.
2.1 The "Keep a Changelog" Format
The undisputed "Gold Standard" for changelog formatting is the Keep a Changelog convention. This format emphasizes that a changelog is for humans, not machines. It rejects the practice of simply dumping git log output, which is often filled with noise (e.g., "fix typo," "merge branch"). Instead, it requires curation.14
Core Structural Requirements:
1. Reverse Chronological Order: The most recent release is always at the top.
2. Versioning and Dating: Every entry header must include the semantic version and the ISO 8601 date (YYYY-MM-DD).
3. Links: Each version header should link to the diff view on GitHub (e.g., [1.2.0]: https://github.com/.../compare/v1.1.0...v1.2.0), enabling code-level auditability.
2.2 Categorization Schema
To maximize readability, changes within a release block must be grouped by the nature of the impact. This allows a user to quickly scan for "Did they fix that bug?" without wading through internal refactoring notes.
Recommended Categories:
* 🚀 Added: New features (e.g., "Added context menu integration for magnet links").
* ⚡ Changed: Changes in existing functionality (e.g., "Changed the default refresh rate from 2s to 5s").
* 🗑️ Deprecated: Features that will be removed in upcoming releases (crucial for API consumers or power users with custom scripts).
* 🔥 Removed: Features deleted in this release.
* 🐛 Fixed: Bug fixes (e.g., "Fixed connection timeout when using a proxy").
* 🔒 Security: Updates addressing vulnerabilities (e.g., "Patched XSS vulnerability in the options page").
Insight: The use of emojis in these headers (as seen above) is increasingly common in modern open-source projects (like semantic-release-gitmoji), as it provides visual anchors that speed up scanning.15
2.3 Dual-Stream Architecture: User vs. Developer Logs
A common dilemma is whether to maintain one detailed log or two separate logs. For a complex extension like "Torrent Control Reloaded," a Hybrid/Filtered approach is recommended over maintaining two manual files.
The Hybrid Approach:
Maintain a single source of truth: CHANGELOG.md in the repository root. This file contains everything, including technical details ("Refactored Redux store").
* For Developers: They read CHANGELOG.md directly on GitHub.
* For Users: The build pipeline should extract a subset of this log for the "What's New" page. By tagging entries (e.g., explicitly marking user-facing items), the release script can generate a simplified release-notes.json that is bundled into the extension.
   * Mechanism: The release script parses CHANGELOG.md and filters out the Security (unless critical) and technical Changed items, keeping mostly Added and Fixed items for the user display.14
2.4 Proposed CHANGELOG.md Template
Below is the proposed template for "Torrent Control Reloaded," adhering to the Gold Standard.
Changelog
All notable changes to the "Torrent Control Reloaded" project will be documented in this file.
The format is based on Keep a Changelog,
and this project adheres to(https://semver.org/spec/v2.0.0.html).
[Unreleased]
[1.2.0] - 2025-12-03
🚀 Added
* Added support for qBittorrent v4.6.x authentication protocols.
* Implemented a "Dark Mode" toggle in the options page (#42).
* Added ability to prioritize files within a torrent via the file tree view.
⚡ Changed
* Migrated background script to Service Worker to comply with Manifest V3.
* Improved torrent list rendering performance by implementing list virtualization; lists with 1000+ items now scroll smoothly.
🐛 Fixed
* Fixed issue where the global download speed badge would freeze on browser restart (#38).
* Resolved permission warning on Chrome 130+ regarding activeTab.
[1.1.0] - 2025-10-15
🚀 Added
* Initial support for Deluge web client API.
* Added localization for French and German languages.
🔒 Security
* Removed unsafe-eval from Content Security Policy to improve security posture.
* Updated axios dependency to patch CVE-2025-1234.
________________
3. Release Notes: Marketing and Communication
While the changelog serves as the historical record, the Release Notes function as the marketing vehicle for the update. These appear in the Chrome Web Store "What's New" tab, the Mozilla Add-ons description, and the post-install welcome page. The goal of release notes is not to document every change, but to sell the update's value to the user.
3.1 Writing Compelling Store Release Notes
Store listings have strict character limits and limited formatting capabilities. Users rarely read long blocks of text.
Best Practices:
1. The "Hook" Summary: Begin with a single sentence summarizing the update’s primary value.
   * Weak: "Version 2.0.0 update includes bug fixes."
   * Strong: "v2.0: Now 50% faster with a complete visual redesign and Dark Mode support."
2. Benefit-Centric Language: Translate technical features into user benefits.
   * Feature: "Implemented virtualized-list for torrent rendering."
   * Benefit: "Torrent lists now load instantly, even if you have thousands of active downloads."
3. Human Tone: Avoid developer jargon. Use "Fixed login issues" instead of "Patched Auth token race condition."
4. Call to Action (CTA): Encouraging engagement helps with store algorithm ranking. "Enjoying the new speed? Please leave us a 5-star review!".17
3.2 In-Extension Communication: The "What's New" Experience
Because extensions update silently in the background, users often miss new features entirely. Worse, if a feature changes (e.g., a button moves), users may assume the extension is broken. The "Best in Class" standard is to detect an update and proactively inform the user.
3.2.1 The Update Detection Pattern
Use the chrome.runtime.onInstalled listener to detect when the extension has been updated.19


TypeScript




// src/background.ts
chrome.runtime.onInstalled.addListener((details) => {
 if (details.reason === chrome.runtime.OnInstalledReason.UPDATE) {
   const currentVersion = chrome.runtime.getManifest().version;
   const previousVersion = details.previousVersion;

   if (previousVersion!== currentVersion) {
     // Logic to handle the update announcement
     handleUpdateAnnouncement(currentVersion, previousVersion);
   }
 }
});

3.2.2 The "Toast" vs. "New Tab" Debate
Historically, extensions would open a new tab (Tab-Jacking) to show release notes. This is now considered intrusive and is discouraged by UX guidelines.
* The "Toast" Notification (Recommended): When the user clicks the extension icon after an update, inject a small, dismissible banner at the top of the popup: "Updated to v1.2.0! See what's new."
* The Badge Indication: Set a badge text (e.g., NEW) on the extension icon to draw attention.
* Major Update Exception: For MAJOR updates (e.g., v1.0 to v2.0) that require user re-authentication or learning a new UI, opening a new tab is acceptable and necessary to prevent confusion.10
3.3 Case Studies of Excellence
* uBlock Origin: Uses a minimalist approach. When the extension updates, the version number in the popup is highlighted. Clicking it leads to a detailed, text-heavy release dashboard. This works for their technical audience.22
* Grammarly: Upon a major update, Grammarly often opens a specialized "Onboarding" tab that uses interactive React components to demonstrate new features (e.g., "Try the new tone detector here"). This interactive "Show, Don't Tell" approach significantly increases feature adoption.24
* React Developer Tools: After an update, the DevTools panel itself displays a "What's New" banner. This is context-sensitive—it only appears when the user is actually using the tool, rather than interrupting their browsing flow.25
________________
4. Automation and Tooling: The CI/CD Pipeline
Manual release processes are the enemy of reliability. In an extension project, the risk of desynchronization between package.json, manifest.json, and git tags is high. A "Best in Class" pipeline automates this entirely, ensuring that the version in the code is exactly the version in the tag and the build artifact.
4.1 Tool Selection: The Ecosystem
4.1.1 semantic-release
Philosophy: Fully automated, opinionated. It runs in CI, analyzes commits, determines the version, releases, and publishes.
Pros: Enforces discipline. Zero manual touchpoints.
Cons: Can be difficult to configure for extensions because the "publish" step isn't a simple npm publish. It requires zipping artifacts and interacting with complex Google/Mozilla APIs.
Verdict: Powerful, but potentially overkill if you want manual control over when the CWS submission happens.26
4.1.2 standard-version (and forks)
Philosophy: Local automation. The developer runs a command (e.g., npm run release) which bumps versions, updates changelogs, and creates tags locally. The developer then pushes these tags to CI.
Status: standard-version is deprecated. The active fork is commit-and-tag-version or release-it.28
Verdict: Recommended for Extensions. It allows the developer to inspect the generated changelog and artifact before triggering the irreversible upload to the store. This "human-in-the-loop" approach is safer given the rigorous review process of extension stores.
4.1.3 changesets
Philosophy: Designed for monorepos. Developers add "changeset" files alongside their PRs.
Verdict: Excellent for monorepos, but likely unnecessary complexity for a single extension repo like "Torrent Control Reloaded."
4.2 The "Single Source of Truth" Architecture
You have multiple files defining the version: package.json, manifest.json (Chrome), and possibly manifest.firefox.json.
Architecture: package.json must be the Single Source of Truth.
The build pipeline must be configured to read the version from package.json and inject it into the manifest.json at build time. This prevents the "I forgot to update the manifest" error.
Implementation with Vite (vite.config.ts):
Tools like vite-plugin-web-extension or @crxjs/vite-plugin support this natively.


TypeScript




// vite.config.ts
import { defineConfig } from "vite";
import webExtension from "@samrum/vite-plugin-web-extension";
import packageJson from "./package.json";

export default defineConfig({
 plugins:,
});

.31
4.3 CI/CD Pipeline Implementation (GitHub Actions)
The pipeline consists of three distinct stages: Validation, Versioning, and Publishing.
4.3.1 Stage 1: Validation (Pull Request)
Runs on every PR.
* Lint/Typecheck: eslint, prettier, tsc.
* Test: Unit tests (Jest/Vitest).
* Commit Lint: Verify that commit messages follow the Conventional Commits standard (Angular style). This ensures that the automated versioning tool in the next stage won't fail.34
4.3.2 Stage 2: Versioning (Merge to Main)
Runs when a PR is merged to main.
* Tool: release-it or commit-and-tag-version.
* Action:
   1. Analyzes commits since last tag.
   2. Bumps version in package.json.
   3. Generates CHANGELOG.md.
   4. Commits these changes and creates a Git Tag (e.g., v1.2.0).
   5. Pushes back to main.
4.3.3 Stage 3: Publishing (Tag Trigger)
Runs when a new Tag (v*) is pushed.
* Build: Runs the Vite build. The config injects the new version into manifest.json.
* Pack: Zips the dist folder into extension-v1.2.0.zip.
* Release: Creates a GitHub Release and attaches the zip file.
* Store Upload (Optional): Uses API actions to upload to Chrome Web Store and AMO.
   * Tools: chrome-webstore-upload-cli or browser-actions/release-chrome-extension.36
   * Security Note: Storing CWS Refresh Tokens in GitHub Secrets is secure, but Google's tokens can expire if not used. A robust pipeline handles token refresh failures gracefully.
________________
5. Implementation Guide for "Torrent Control Reloaded"
This section translates the strategy into concrete implementation steps for the immediate adoption by the team.
5.1 Project Configuration
File Structure:
/
├──.github/
│ └── workflows/
│ ├── test.yml # Runs on PR
│ └── release.yml # Runs on Tag push
├── src/
│ ├── manifest.json # Source manifest (version can be placeholder)
│ ├── background/
│ └── popup/
├── scripts/
│ └── update-manifest.js # Helper for version sync
├──.releaserc.json # Automation config
├── CHANGELOG.md
├── package.json
└── vite.config.ts
5.2 Commit Message Standard (Adoption Guide)
The team must adopt Conventional Commits. This is the fuel for the automation engine.
Commit Message
	Release Type Triggered
	Example
	feat(ui): add progress bar
	MINOR
	New feature.
	fix(api): handle timeout
	PATCH
	Bug fix.
	docs: update readme
	NONE
	Documentation only.
	chore: update deps
	NONE
	Maintenance.
	feat!: drop support for v1
	MAJOR
	Breaking change (Note the !).
	5.3 Configuration Files
.releaserc.json (for commit-and-tag-version)


JSON




{
 "header": "# Changelog\n\nAll notable changes to 'Torrent Control Reloaded'...",
 "types": [
   {"type": "feat", "section": "🚀 Added"},
   {"type": "fix", "section": "🐛 Fixed"},
   {"type": "chore", "hidden": true},
   {"type": "docs", "hidden": true},
   {"type": "style", "hidden": true},
   {"type": "refactor", "hidden": true},
   {"type": "perf", "section": "⚡ Changed"},
   {"type": "test", "hidden": true}
 ],
 "bumpFiles": [
   {"filename": "package.json", "type": "json"},
   {"filename": "src/manifest.json", "type": "json"} 
 ]
}

Note: We include src/manifest.json in bumpFiles to ensure the source manifest is updated on the filesystem, aiding local development.38
release.yml (GitHub Action)


YAML




name: Release Extension
on:
 push:
   tags:
     - 'v*' # Trigger on version tags

jobs:
 build-and-publish:
   runs-on: ubuntu-latest
   steps:
     - uses: actions/checkout@v3
     - uses: actions/setup-node@v3
       with:
         node-version: '18'
         registry-url: 'https://registry.npmjs.org'

     - name: Install Dependencies
       run: npm ci

     - name: Build Extension
       run: npm run build
       # Vite config handles manifest version syncing from package.json

     - name: Zip Artifact
       run: cd dist && zip -r../extension.zip.

     - name: Create GitHub Release
       uses: softprops/action-gh-release@v1
       with:
         files: extension.zip
         body_path: CHANGELOG.md # Or extract specific section
       env:
         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

     - name: Upload to Chrome Web Store
       uses: mobilefirstllc/cws-publish@latest
       with:
         action: 'upload' # Upload only. Manual publish recommended for safety.
         client_id: ${{ secrets.CWS_CLIENT_ID }}
         client_secret: ${{ secrets.CWS_CLIENT_SECRET }}
         refresh_token: ${{ secrets.CWS_REFRESH_TOKEN }}
         extension_id: ${{ secrets.CWS_EXTENSION_ID }}
         zip_file: 'extension.zip'

5.4 The "Golden Path" Release Checklist
To ensure a "Best in Class" release every time, the Release Engineer should follow this sequence:
1. Code Freeze: Ensure all features for the release are merged to main.
2. Dry Run: Locally run npm run release -- --dry-run. Check the output:
   * Is the next version number correct? (e.g., Are we jumping to 2.0.0 unexpectedly?)
   * Is the generated Changelog accurate and readable?
3. Release Execution: Run npm run release. This bumps the version, writes the changelog, and pushes the tag to GitHub.
4. CI Monitoring: Watch the GitHub Action. Ensure the build succeeds and the artifact is attached to the Release.
5. Artifact Audit: Download the extension.zip from GitHub Releases.
   * Unzip and inspect manifest.json.
   * Verify version is correct.
   * Verify no forbidden files (e.g., .env, key files) are included.
6. Store Submission:
   * The CI action uploaded the draft to CWS. Log in to the CWS Dashboard.
   * Edit Store Listing: Paste the simplified release notes into the description or "What's New" field.
   * Submit for Review: Click "Submit for Review."
7. Post-Release: Once the extension is live (after review), monitor Sentry/Error logs for regression spikes.
Conclusion
By adopting this standardized framework, "Torrent Control Reloaded" moves from an ad-hoc release process to a mature, engineering-driven lifecycle. The combination of Semantic Versioning for clarity, Keep a Changelog for documentation, and GitHub Actions for automation creates a resilient pipeline. This structure not only reduces the risk of store rejections and broken builds but also builds trust with the user base through consistent, transparent communication. Implementation of these standards will position the extension as a professional-grade software product in the crowded browser ecosystem.
Works cited
1. Software versioning - Wikipedia, accessed December 3, 2025, https://en.wikipedia.org/wiki/Software_versioning
2. Any opinions on calver vs semver for, say, open source projects or APIs/SDKs?, accessed December 3, 2025, https://news.ycombinator.com/item?id=21968327
3. SemVer vs. CalVer: Choosing the Best Versioning Strategy for Your Project | SensioLabs, accessed December 3, 2025, https://sensiolabs.com/blog/2025/semantic-vs-calendar-versioning
4. From 1.0.0 to 2025.4: Making sense of software versioning - WorkOS, accessed December 3, 2025, https://workos.com/blog/software-versioning-guide
5. When to use SemVer or CalVer: project type considerations - Frontside, accessed December 3, 2025, https://frontside.com/blog/2022-02-09-semver-or-calver-by-project-type/
6. Manifest - Version | Chrome Extensions, accessed December 3, 2025, https://developer.chrome.com/docs/extensions/reference/manifest/version
7. Legacy Version Formats - Mozilla - MDN Web Docs, accessed December 3, 2025, https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/version/format
8. version - MDN Web Docs - Mozilla, accessed December 3, 2025, https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/version
9. Versioning and releasing larger Chrome extensions - Dave Stewart, accessed December 3, 2025, https://davestewart.co.uk/blog/extension-versioning/
10. UX Best Practices That Will Make Your Browser Extension Successful - Plasmo, accessed December 3, 2025, https://www.plasmo.com/blog/posts/ux-best-practices-that-will-make-your-browser-extension-successful
11. Extensions / Manifest V3 - Chrome for Developers, accessed December 3, 2025, https://developer.chrome.com/docs/extensions/develop/migrate/what-is-mv3
12. Publish Chrome extension to Chrome Web Store · Actions · GitHub Marketplace, accessed December 3, 2025, https://github.com/marketplace/actions/publish-chrome-extension-to-chrome-web-store
13. Best practices for updating your extension, accessed December 3, 2025, https://extensionworkshop.com/documentation/manage/best-practices-for-updating/
14. The importance of a good changelog - WordPress Developer Resources, accessed December 3, 2025, https://developer.wordpress.org/news/2025/11/the-importance-of-a-good-changelog/
15. Changelog — Omniverse Kit, accessed December 3, 2025, https://docs.omniverse.nvidia.com/kit/docs/omni.kit.window.content_browser/3.1.4/CHANGELOG.html
16. Keep a Changelog - Visual Studio Marketplace, accessed December 3, 2025, https://marketplace.visualstudio.com/items?itemName=RLNT.keep-a-changelog
17. How to Write Release Notes: Best Practices, Examples & Templates - Candu, accessed December 3, 2025, https://www.candu.ai/blog/how-to-write-release-notes-best-practices-examples-templates
18. A Guide To Release Notes (Plus A Free Template + Examples!) - Slite, accessed December 3, 2025, https://slite.com/en/learn/release-notes
19. This is how I notify users of new features : r/chrome_extensions - Reddit, accessed December 3, 2025, https://www.reddit.com/r/chrome_extensions/comments/1jzpmfz/this_is_how_i_notify_users_of_new_features/
20. The Chrome Extension update lifecycle, accessed December 3, 2025, https://developer.chrome.com/docs/extensions/develop/concepts/extensions-update-lifecycle
21. Chrome Enterprise and Education release notes - Google Help, accessed December 3, 2025, https://support.google.com/chrome/a/answer/7679408?hl=en&co=CHROME_ENTERPRISE._Product%3DChromeBrowser
22. uBlock Origin - Wikipedia, accessed December 3, 2025, https://en.wikipedia.org/wiki/UBlock_Origin
23. uBlock Origin 1.55.* Announcement Thread || Please respect the subreddit Rules and Posting Guidelines : r/uBlockOrigin, accessed December 3, 2025, https://www.reddit.com/r/uBlockOrigin/comments/18xyqw5/ublock_origin_155_announcement_thread_please/
24. Grammarly Authorship: Ensure Authentic Writing in the Age of AI, accessed December 3, 2025, https://www.grammarly.com/authorship
25. Changelog 61: React DevTools V3 ⚛️ - Replay.io Blog, accessed December 3, 2025, https://blog.replay.io/changelog-61:-react-devtools-v3
26. Using semantic-release to automate releases and changelogs - LogRocket Blog, accessed December 3, 2025, https://blog.logrocket.com/using-semantic-release-automate-releases-changelogs/
27. semantic-release/semantic-release: :package::rocket: Fully automated version management and package publishing - GitHub, accessed December 3, 2025, https://github.com/semantic-release/semantic-release
28. Commit and Tag Version - SOOS, accessed December 3, 2025, https://app.soos.io/research/packages/NPM/-/commit-and-tag-version/
29. conventional-changelog/standard-version: :trophy: Automate versioning and CHANGELOG generation, with semver.org and conventionalcommits.org - GitHub, accessed December 3, 2025, https://github.com/conventional-changelog/standard-version
30. release-it/release-it: Automate versioning and package publishing - GitHub, accessed December 3, 2025, https://github.com/release-it/release-it
31. vite-plugin-web-extension-support-inject - Yarn Classic, accessed December 3, 2025, https://classic.yarnpkg.com/en/package/vite-plugin-web-extension-support-inject
32. Getting Started | Vite Plugin Web Extension, accessed December 3, 2025, https://vite-plugin-web-extension.aklinker1.io/guide/
33. Packaging - CRXJS, accessed December 3, 2025, https://crxjs.dev/guide/packaging/
34. Automatically Version with Conventional Commits - Nx, accessed December 3, 2025, https://nx.dev/docs/guides/nx-release/automatically-version-with-conventional-commits
35. Automate Semantic Versioning with Conventional Commits | by jsilvax - Medium, accessed December 3, 2025, https://medium.com/@jsilvax/automate-semantic-versioning-with-conventional-commits-d76a9f45f2fa
36. browser-actions/release-chrome-extension - GitHub, accessed December 3, 2025, https://github.com/browser-actions/release-chrome-extension
37. fregante/chrome-webstore-upload-cli - GitHub, accessed December 3, 2025, https://github.com/fregante/chrome-webstore-upload-cli
38. @types/standard-version@7.1.3 - jsDocs.io, accessed December 3, 2025, https://www.jsdocs.io/package/@types/standard-version