Strategic Architecture & Migration Report: Torrent Control Refactoring Analysis




1. Executive Summary


This report presents a rigorous architectural analysis and execution strategy for the comprehensive modernization of the "Torrent Control" browser extension. Currently implemented in a legacy stack comprising Vanilla JavaScript, HTML, and custom CSS, the project faces significant challenges related to maintainability, scalability, and platform compliance, particularly with the industry-wide shift to Manifest V3 (MV3). The proposed migration to a modern technical stack—TypeScript, React (leveraging Preact for performance), Tailwind CSS, and the WXT framework—represents a critical inflection point for the project's lifecycle.
The analysis herein is driven by the dual imperatives of resolving immediate technical debt—evidenced by user reports of unhandled API errors and UI fragility—and establishing a robust foundation for future feature development. By transitioning from imperative DOM manipulation to a declarative, component-based UI architecture, and by adopting a strictly typed language, the project aims to eliminate entire classes of runtime errors that currently plague the user base. Furthermore, the adoption of WXT provides a unified, Vite-based build system that abstracts the increasingly complex requirements of cross-browser compatibility and MV3 compliance, positioning "Torrent Control" as a premier open-source utility in its category.
Our recommended execution path utilizes the "Strangler Fig" migration pattern. This approach allows for the incremental introduction of the modern stack alongside the legacy codebase, thereby mitigating the risks associated with a "Big Bang" rewrite while ensuring continuous delivery of value to the user base. This report details the specific technical mechanisms, architectural decisions, and long-term implications of this strategic initiative.
________________


2. Introduction: The Strategic Imperative for Modernization




2.1 Project Context and Current State


"Torrent Control" operates as a critical bridge between the user's web browsing experience and their remote content management infrastructure. As an open-source browser extension, its primary function is to intercept magnet links and torrent files, dispatching them to remote download clients such as rTorrent, Deluge, Transmission, and qBittorrent. The current codebase, hosted on GitHub under Mika-/torrent-control, reflects a development paradigm that predates modern JavaScript tooling.1
The existing architecture is characterized by a "Vanilla" stack:
* Core Logic: Implemented in untyped ECMAScript 5/6 JavaScript (94.0% of the codebase), relying heavily on global scope and direct XMLHttpRequest or fetch calls.1
* User Interface: Constructed using static HTML files (popup.html, options.html) with imperative JavaScript used to inject dynamic content and handle user interactions.
* Styling: Custom CSS (1.4%) that lacks encapsulation, leading to potential style conflicts when injecting content into host pages.1
While the extension has maintained a respectable user rating of 4.4 out of 5 stars 2, qualitative data from user reviews and issue trackers indicates a growing fragility. Users frequently encounter "Unknown response" errors, broken notification rendering where raw HTML is displayed instead of parsed text, and connectivity issues related to complex network topologies like Docker containers and reverse proxies.2 These issues are symptomatic of a codebase that lacks rigid contract enforcement and error handling mechanisms.


2.2 The Drivers for Migration


The decision to migrate is driven by three converging factors: Technical Debt, Platform Evolution, and Community Viability.
Technical Debt and Reliability
The current reliance on loose typing means that changes in upstream APIs (e.g., a version update in qBittorrent changing a JSON key) can cause catastrophic runtime failures that are difficult to debug. The lack of a compilation step means syntax errors or type mismatches are often discovered by users in production rather than by developers during the build process.
Platform Evolution: The Manifest V3 Mandate
The browser extension ecosystem is undergoing its most significant shift in a decade with the mandatory transition to Manifest V3 (MV3). MV3 fundamentally changes the extension execution model, moving from persistent background pages to ephemeral service workers. This shift requires a stateless architecture that is difficult to retrofit onto a legacy codebase reliant on global variables and persistent state. Adopting a framework like WXT, which natively handles MV3 polyfills and state abstractions, is a strategic necessity to ensure the extension remains publishable on the Chrome Web Store.4
Community Viability and Talent Attraction
As an open-source project, "Torrent Control" relies on community contributions for maintenance and feature expansion. The "State of JS 2024" and Stack Overflow Developer Survey 2024 indicate a decisive market shift: TypeScript is used by nearly 40% of professional developers and is highly admired, while React remains the dominant UI library.5 A codebase written in "jQuery-style" Vanilla JS acts as a deterrent to modern contributors who are accustomed to component-driven development and strong typing. Modernizing the stack is, therefore, a recruitment strategy to revitalize the project's contributor base.
________________


3. Comprehensive Architectural Audit of the Legacy System


To chart a course for migration, we must first deeply understand the terrain of the existing system. This audit dissects the legacy architecture to identify specific failure modes and structural weaknesses that the new stack must address.


3.1 Codebase Structure and Static Analysis


The repository structure of Mika-/torrent-control is typical of extensions developed without a build pipeline. The root directory contains manifest.json alongside source folders src/ and test/.1
Imperative DOM Manipulation
The UI logic relies on imperative DOM manipulation. For example, rendering the list of torrent clients in the options page likely involves creating string templates and injecting them via innerHTML. This approach, often referred to as "spaghetti code," tightly couples the data retrieval logic with the view rendering logic. As the complexity of the UI grows—for instance, users have requested a "generic client option" and YouTube downloading capabilities 2—this coupling makes the codebase exponentially harder to maintain. A simple change to the HTML structure requires a corresponding update to the JavaScript selectors, a process prone to regression errors.
Untyped API Interactions
The extension interacts with a diverse array of third-party APIs (uTorrent, Transmission, Vuze, etc.). In the current JavaScript implementation, these interactions are untyped. The code assumes that a response from Transmission will always match a specific JSON structure. However, network errors, authentication failures (returning 403 HTML pages), or API version changes can violate these assumptions.
* Evidence: User reviews explicitly mention "Notification pop-ups are annoying... showing the HTML code, instead of actual text".2
* Diagnosis: This occurs when the fetch handler receives a non-200 response (like a 404 or 500 HTML error page from a server behind a reverse proxy) and blindly attempts to display it or parse it as JSON. Without TypeScript interfaces to enforce response validation, these errors propagate to the UI layer.


3.2 Network and Connectivity Analysis


The extension operates in complex network environments. Users often run torrent clients on "seedboxes," home servers behind reverse proxies (Nginx/Traefik), or inside Docker containers.3
* The "Localhost" Fallacy: Issues have been reported where the extension attempts to load torrents from 127.0.0.1, failing because the rTorrent instance inside a container sees a different localhost than the browser.3
* CORS and Mixed Content: The legacy codebase likely relies on standard fetch or XMLHttpRequest. These are subject to Cross-Origin Resource Sharing (CORS) restrictions unless specifically handled by the extension's background page. In MV3, the service worker environment handles requests differently, and a naive migration of vanilla fetch code often fails due to missing cookie stores or strict CORB (Cross-Origin Read Blocking) policies.


3.3 The "Vanilla Trap" in 2025


While proponents of Vanilla JS argue for its performance benefits and lack of build complexity 7, for an application of this complexity, it becomes a liability.
* State Management Fragmentation: In the current architecture, state (e.g., the list of configured servers, the last used download directory) is likely scattered across localStorage, DOM elements in the background page, and variables in the popup. Synchronizing this state requires manual message passing via chrome.runtime.sendMessage, which is asynchronous and error-prone.
* Lack of Reusability: Logic for authentication or URL parsing is often duplicated between the background script and the options page script because sharing code between these contexts in a vanilla setup requires awkward script loading hacks or code duplication.
________________


4. Target Architecture Selection and Justification


The proposed stack—TypeScript, React (Preact), Tailwind CSS, and WXT—is not a random assortment of trendy tools but a carefully curated suite of technologies selected to solve the specific problems identified in the audit.


4.1 The Build Framework: WXT (Web Extension Toolkit)


The choice of the build tool is the single most critical architectural decision. It defines the developer experience, the build pipeline, and the ease of MV3 compliance. We evaluated WXT against its primary competitors, Plasmo and CRXJS.


4.1.1 Comparative Analysis: WXT vs. Plasmo vs. CRXJS




Feature / Criteria
	WXT
	Plasmo
	CRXJS
	Core Bundler
	Vite 8
	Parcel 8
	Vite
	Maintainer Health
	High Activity 9
	"Maintenance Mode" Concerns 10
	Moderate
	HMR Reliability
	Excellent (UI & Content)
	Mixed (React Issues) 10
	Good
	Manifest Gen
	Automated (File-based) 11
	Automated
	Manual
	API Abstractions
	Storage, Messaging, UI 12
	Storage, Messaging
	None
	Cross-Browser
	Native Firefox/Safari Support
	Good
	Chrome-centric
	Auto-Imports
	Yes (Nuxt-style) 4
	No
	No
	Justification for WXT:
* Vite vs. Parcel: WXT leverages Vite, which has become the industry standard for frontend tooling due to its speed and Rollup-based production builds. Plasmo relies on Parcel, which users have reported as having upstream bugs and being slower to update.10 For a long-term strategic migration, betting on the Vite ecosystem is the safer choice.
* Abstraction Layer: WXT provides high-level abstractions for common extension patterns. Its entrypoints/ directory structure automatically generates the manifest.json, ensuring that permissions are added only when referenced. This reduces the risk of human error in managing the complex manifest configuration.11
* MV3 Polyfills: WXT handles the nuances of MV3/MV2 compatibility internally. This is crucial for "Torrent Control," which supports Firefox (where MV2 is still prevalent) and Chrome (where MV3 is mandatory). WXT allows a single codebase to build for both targets seamlessly.4


4.2 The Language: TypeScript


Migrating to TypeScript is the primary mechanism for resolving the stability issues identified in the audit.
* Contractual Integrity: By defining strict interfaces for every supported torrent client (e.g., interface DelugeResponse { result: string; error: null | object }), we enforce a contract at compile time. Any code that attempts to access response.data instead of response.result will fail the build, preventing runtime crashes.
* Refactoring Safety: As we modernize the codebase, we will be moving vast amounts of logic. TypeScript provides the safety rails to ensure that a function moved from legacy_background.js to utils/client.ts is called with the correct arguments in its new location.13


4.3 The UI Library: React (via Preact)


The user prompt suggests React or Vue. We recommend React, but specifically utilizing Preact via compatibility aliasing.
Why React?
* Declarative UI: React allows us to describe the UI state (e.g., "Scanning," "Success," "Error") and let the framework handle the DOM updates. This eliminates the spaghetti code of imperative DOM manipulation.
* Ecosystem: The React ecosystem offers a vast array of libraries for form validation, routing, and state management that can be leveraged to build a robust Options page.7
The Performance Nuance: Preact
A key metric for browser extensions is "popup opening time." A heavy framework bundle can cause a noticeable lag when the user clicks the extension icon.
* React Bundle Size: Standard React + ReactDOM weighs approximately 40KB (gzipped).
* Preact Bundle Size: Preact weighs approximately 3KB.14
* Strategic Decision: We will write the code using standard React syntax and hooks (e.g., useState, useEffect) but configure Vite to alias react and react-dom to preact/compat during the build. This provides the superior developer experience of React with the lightweight performance profile of a vanilla extension.15


4.4 Styling: Tailwind CSS in the Shadow DOM


Tailwind CSS offers a utility-first approach that speeds up development and ensures design consistency. However, using it in a browser extension—specifically in content scripts injected into third-party websites—presents a unique challenge.
The Shadow DOM Challenge
To prevent the host website's CSS from breaking our extension's UI (and vice versa), we must encapsulate our UI in a Shadow DOM.
* The "rem" Problem: Tailwind uses rem units by default. 1rem is relative to the root <html> font size of the page. If a website sets html { font-size: 62.5%; }, our UI will render at roughly 60% of its intended size.16
* The Solution: We will employ a PostCSS plugin (@thedutchcoder/postcss-rem-to-px) to convert all rem units to static px values at build time. This ensures that the "Torrent Control" UI looks identical on every website, regardless of the host page's CSS environment.17
________________


5. Migration Methodology: The Strangler Fig Pattern


Attempting a "Big Bang" rewrite—stopping all development to rewrite the entire application from scratch—is a known anti-pattern that leads to stalled releases and project failure. Instead, we will apply the Strangler Fig Pattern. This architectural pattern involves building the new system around the edges of the old one, gradually routing functionality to the new components until the legacy system can be decommissioned.18


5.1 Phase 1: Infrastructure Initialization and Hybrid Coexistence


The first step is to establish the new WXT infrastructure without breaking the existing extension.
Step 1: WXT Scaffolding
We will initialize a new WXT project in the root of the existing repository. WXT supports a "Vanilla" template, which is crucial for this phase.
* Action: Run npx wxt@latest init and configure wxt.config.ts to mirror the permissions and settings from the legacy manifest.json.
* Directory Structure: We will reorganize the repository. The legacy source code (currently in src/) will be moved to a legacy/ directory or mapped as raw entry points. WXT uses an entrypoints/ directory for its build inputs.
Step 2: Asset Migration
All static assets (icons, legacy CSS) will be moved to the public/ directory or assets/ directory depending on whether they need processing. This ensures they are available in the final build.20
Step 3: Dual Build Pipeline
We will configure WXT to build the legacy background script and content scripts as-is. This proves that the new build system (Vite) can successfully bundle the existing code before we write a single line of React.


5.2 Phase 2: The Options Page (Low Risk, High Value)


The Options page is the ideal candidate for the first React migration. It is isolated, complex (benefiting from React's component model), and failure here is less critical than in the popup or background script.
Implementation Plan:
1. Create Entry Point: Create entrypoints/options/index.html and entrypoints/options/main.tsx.
2. State Migration: The legacy options page likely reads from localStorage or chrome.storage. We will create a custom React Hook, useExtensionSettings(), that wraps WXT's storage API. This hook will provide reactive state to the React components.
   * Benefit: When a user toggles a setting, the hook automatically handles the chrome.storage.set call and updates the local state, eliminating the imperative boilerplate of document.getElementById(...).value.12
3. Component Architecture: We will break the monolithic options HTML into components: <ServerConfig />, <ClientSelection />, <NotificationSettings />. This modularity makes it easier to add support for new clients in the future.


5.3 Phase 3: The Popup (High Visibility, Performance Critical)


Once the React/Preact stack is proven in the Options page, we move to the Popup. This is the primary user interface.
Implementation Plan:
1. Performance Tuning: We will ensure preact/compat is correctly aliased to minimize the startup time.
2. Messaging Integration: The Popup needs to communicate with the background script to get the current status of the torrent client. We will migrate from untyped chrome.runtime.sendMessage to a typed messaging library like @webext-core/messaging.22
   * Implementation: Define a ProtocolMap interface that lists all valid messages (e.g., ADD_TORRENT, GET_STATUS). The Popup will use this typed client to send messages, ensuring that it never sends an invalid command.
3. Error Handling UI: We will implement a global Error Boundary and specific error states in the UI to gracefully handle the "Unknown response" issues. If the background script returns a structured error (as defined in our new TypeScript interfaces), the Popup will render a user-friendly toast notification rather than crashing or showing HTML.2


5.4 Phase 4: Content Scripts (Shadow DOM Implementation)


The content script is responsible for parsing the page for .torrent links and magnet URIs.
Implementation Plan:
1. Shadow DOM Injection: We will replace the legacy injection logic with WXT's createShadowRootUi. This API simplifies the creation of a Shadow Root and handles the injection of our Tailwind styles.17
   * Code Example:
TypeScript
import { createShadowRootUi } from 'wxt/client';
import './style.css'; // Tailwind

export default defineContentScript({
 matches: ['<all_urls>'],
 async main(ctx) {
   const ui = await createShadowRootUi(ctx, {
     name: 'torrent-control-overlay',
     position: 'inline',
     onMount: (uiContainer) => {
       // Mount Preact App
       render(<DownloadOverlay />, uiContainer);
     }
   });
   ui.mount();
 }
});

   2. Event Isolation: By using Shadow DOM, we ensure that the extension's event listeners (e.g., clicking the download button) do not interfere with the host page's event bubbling.


5.5 Phase 5: The Background Service Worker (The Core Logic)


This is the final and most complex phase. The legacy background script contains the core logic for communicating with torrent clients.
Implementation Plan:
   1. Service Worker Adoption: We must refactor the background page to be an ephemeral Service Worker for MV3. This means removing any reliance on global variables for state.
   2. State Persistence: Any state that needs to persist between browser restarts (e.g., the queue of added torrents) must be moved to chrome.storage.local or chrome.storage.session. We will use WXT's storage utilities to make this seamless.
   3. Typed API Clients: We will rewrite the client interaction logic (currently untyped fetch calls) into a set of TypeScript classes implementing a common TorrentClient interface.
   * Interface Definition:
TypeScript
interface TorrentClient {
 addTorrent(magnet: string): Promise<AddResult>;
 getStatus(): Promise<ClientStatus>;
}

   * Impact: This standardization makes it trivial to add new clients. A contributor simply needs to implement this interface.
________________


6. Technical Deep Dives




6.1 Type-Safe Messaging Architecture


In the legacy codebase, message passing is likely handled via string literals, e.g., sendMessage('add_torrent', link). This is brittle; a typo in the string name leads to silent failures.
The Modern Approach:
We will utilize @webext-core/messaging to enforce a strict contract between the Popup/Content Scripts and the Background Service Worker.22
Protocol Definition:


TypeScript




// utils/messaging.ts
import { defineExtensionMessaging } from '@webext-core/messaging';

interface Protocol {
 addMagnetLink(link: string): Promise<{ success: boolean; id?: string; error?: string }>;
 getClientStatus(): Promise<{ connected: boolean; downloadSpeed: number }>;
}

export const messenger = defineExtensionMessaging<Protocol>();

Implementation:
      * Sender (Popup): await messenger.sendMessage('addMagnetLink', magnetUrl);
      * If the developer types addMagentLink, TypeScript will refuse to compile.
      * The return type is inferred automatically, so result.success is typed as boolean.
      * Receiver (Background):
TypeScript
messenger.onMessage('addMagnetLink', async ({ data }) => {
 return await client.add(data);
});



6.2 Storage Abstractions and Hooks


Handling chrome.storage involves asynchronous callbacks or promises, which can lead to "callback hell" in vanilla JS. We will abstract this into React Hooks for the UI and typed utilities for the background.12
WXT Storage Utility:
WXT allows defining storage items with validation and default values.


TypeScript




import { storage } from 'wxt/storage';

export const serverConfig = storage.defineItem<ServerConfig>('local:serverConfig', {
 defaultValue: { url: 'http://localhost:8080', type: 'qbittorrent' },
});

Custom React Hook:


TypeScript




export function useServerConfig() {
 const [config, setConfig] = useState<ServerConfig | null>(null);

 useEffect(() => {
   // Initial load
   serverConfig.getValue().then(setConfig);
   // Watch for changes (e.g. if updated in another tab)
   return serverConfig.watch(setConfig);
 },);

 return [config, (newConfig) => serverConfig.setValue(newConfig)];
}

This pattern ensures that the UI is always reactive. If the user changes the server URL in the Options page, the Popup (if open) will immediately reflect the change without a reload.


6.3 Network Layer and Error Handling


To resolve the "Unknown response" errors, we must implement a robust networking layer that handles the vagaries of torrent client APIs.
Discriminated Unions for Error Handling:
Instead of returning generic objects or throwing exceptions, our API client methods will return a discriminated union type.


TypeScript




type ApiResponse<T> =

| { type: 'success'; data: T }
| { type: 'error'; code: 'AUTH_FAILED'; message: string }
| { type: 'error'; code: 'NETWORK_ERROR'; message: string }
| { type: 'error'; code: 'PARSE_ERROR'; raw: string }; // Capture raw HTML for debugging

Implementation Strategy:
The TorrentClient base class will include a safeFetch method. This method will:
         1. Check HTTP status codes.
         2. Check the Content-Type header.
         3. If JSON is expected but HTML is received (common with reverse proxy errors), it will capture a snippet of the HTML and return a PARSE_ERROR.
         4. The UI layer can then check result.type === 'error' and result.code === 'PARSE_ERROR' to display a helpful message: "Received HTML instead of JSON. Check your URL configuration." This directly addresses the user feedback regarding raw HTML in notifications.2
________________


7. Long-Term Effects and Future Outlook




7.1 Maintainability and Code Health


The migration to TypeScript and React will drastically reduce the cognitive load required to maintain the project.
         * Cyclomatic Complexity: By breaking monolithic scripts into small, single-responsibility components and modules, the codebase becomes easier to test and reason about.
         * Self-Documentation: TypeScript interfaces serve as living documentation. A new contributor does not need to guess the shape of the serverConfig object; the IDE tells them.


7.2 Open Source Community Health


Modernizing the stack aligns "Torrent Control" with the preferences of the modern developer community.
         * Contributor Funnel: Developers are more likely to contribute to a project using a standard stack (React/Vite/TS) than one using obscure, custom vanilla JS patterns.
         * Ecosystem Integration: We can leverage the vast NPM ecosystem. For example, adding internationalization (i18n) becomes trivial using libraries like react-i18next, whereas in the legacy stack, it would require writing a custom translation engine.


7.3 Performance and Security


         * Memory Usage: Moving to MV3 Service Workers means the extension consumes zero memory when not in use. This is a significant improvement over persistent MV2 background pages.
         * Security Posture: React's automatic escaping mitigates Cross-Site Scripting (XSS) risks. The strict CSP of MV3 further hardens the extension against remote code execution attacks.


7.4 Future-Proofing


This architecture is designed to last.
         * Browser Agnostic: WXT's abstraction layer allows us to target Chrome, Firefox, Edge, and Safari from a single codebase. As browsers diverge (e.g., Firefox keeping some MV2 features longer), WXT handles the build differences.
         * Feature Expansion: The modular architecture makes it easy to add requested features like a "YouTube Downloader".2 We can simply add a new entrypoints/youtube.content.ts and a corresponding UI component, reusing the existing messaging and storage infrastructure.
________________


8. Conclusion


The migration of "Torrent Control" is not merely a technical housekeeping task; it is a strategic necessity. The legacy architecture, while functional, has reached the limits of its maintainability and reliability. The convergence of user-reported instability and the platform-mandated shift to Manifest V3 creates an urgent imperative for change.
By adopting WXT as the build framework, TypeScript for systemic integrity, Preact for performant UI, and Tailwind CSS for encapsulated styling, we establish a foundation that is robust, scalable, and inviting to contributors. The Strangler Fig Pattern ensures that this transition happens safely, without disrupting the existing user base.
Recommendation: The engineering team should immediately proceed with Phase 1 (Infrastructure Initialization). The cost of delay—measured in accruing technical debt and the looming MV3 enforcement—far outweighs the investment required for this migration. This transformation will elevate "Torrent Control" from a legacy utility to a premier, modern example of browser extension engineering.
Works cited
         1. Mika-/torrent-control: Firefox extension for adding torrents to ... - GitHub, accessed November 27, 2025, https://github.com/Mika-/torrent-control
         2. Reviews for Torrent Control – Add-ons for Firefox (en-CA), accessed November 27, 2025, https://addons.mozilla.org/en-CA/firefox/addon/torrent-control/reviews/?page=4
         3. Torrent Control trying to load torrent from 127.0.0.1 - Network error · Issue #100 - GitHub, accessed November 27, 2025, https://github.com/Mika-/torrent-control/issues/100
         4. WXT: Next-gen Web Extension Framework, accessed November 27, 2025, https://wxt.dev/
         5. Top Frameworks for JavaScript App Development in 2025 - Strapi, accessed November 27, 2025, https://strapi.io/blog/frameworks-for-javascript-app-developlemt
         6. Stack Overflow's 2024 Developer Survey Shows the Gap Between AI Use and Trust in its Output Continues to Widen Among Coders - Press release, accessed November 27, 2025, https://stackoverflow.co/company/press/archive/stack-overflow-2024-developer-survey-gap-between-ai-use-trust/
         7. VanillaJS vs React: Which Requires Less Code? | DistantJob - Remote Recruitment Agency, accessed November 27, 2025, https://distantjob.com/blog/vanillajs-vs-react/
         8. The 2025 State of Browser Extension Frameworks: A Comparative Analysis of Plasmo, WXT, and CRXJS | Redreamality's Blog, accessed November 27, 2025, https://redreamality.com/blog/the-2025-state-of-browser-extension-frameworks-a-comparative-analysis-of-plasmo-wxt-and-crxjs/
         9. Compare - WXT, accessed November 27, 2025, https://wxt.dev/guide/resources/compare
         10. WXT vs. Plasmo. Some thoughts on migrating from Plasmo to WXT. · wxt-dev wxt · Discussion #782 - GitHub, accessed November 27, 2025, https://github.com/wxt-dev/wxt/discussions/782
         11. Entrypoints - WXT, accessed November 27, 2025, https://wxt.dev/guide/essentials/entrypoints.html
         12. Storage - WXT, accessed November 27, 2025, https://wxt.dev/guide/essentials/storage
         13. Documentation - Migrating from JavaScript - TypeScript, accessed November 27, 2025, https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html
         14. Preact vs React 2025: Performance, SEO & Code Comparison - Nimblechapps, accessed November 27, 2025, https://www.nimblechapps.com/blog/preact-vs-react-the-ultimate-performance-showdown-2025
         15. Preact vs React in 2025: Which JavaScript Framework Delivers the Best Performance? | by Keval Padia - Medium, accessed November 27, 2025, https://medium.com/@marketing_96787/preact-vs-react-in-2025-which-javascript-framework-delivers-the-best-performance-f2ded55808a4
         16. How I Finally Made TailwindCSS Work Inside the Shadow DOM (A Real Case Study), accessed November 27, 2025, https://dev.to/dhirajarya01/how-i-finally-made-tailwindcss-work-inside-the-shadow-dom-a-real-case-study-5gkl
         17. Building Modern Cross Browser Web Extensions: Content Scripts and UI (Part 3), accessed November 27, 2025, https://aabidk.dev/blog/building-modern-cross-browser-web-extensions-content-scripts-and-ui/
         18. Strangler Fig Pattern - Azure Architecture Center | Microsoft Learn, accessed November 27, 2025, https://learn.microsoft.com/en-us/azure/architecture/patterns/strangler-fig
         19. The Strangler-Fig Pattern: My Favourite Way to Upgrade Legacy Angular Projects, accessed November 27, 2025, https://javascript.plainenglish.io/the-strangler-fig-pattern-my-favourite-way-to-upgrade-legacy-angular-projects-761fcc727ed1
         20. Migrate to WXT, accessed November 27, 2025, https://wxt.dev/guide/resources/migrate.html
         21. Using localStorage with React Hooks - LogRocket Blog, accessed November 27, 2025, https://blog.logrocket.com/using-localstorage-react-hooks/
         22. Installation - docs - WebExt Core, accessed November 27, 2025, https://webext-core.aklinker1.io/messaging/installation
         23. Content Scripts - WXT, accessed November 27, 2025, https://wxt.dev/guide/essentials/content-scripts.html
         24. use-chrome-storage - NPM, accessed November 27, 2025, https://www.npmjs.com/package/use-chrome-storage