"""
BIND Configuration Manager
Handles reading/writing config.env and daemon restart.
"""

import fcntl
import os
import re
import subprocess


class ConfigManager:
    """Manages BIND configuration via config.env file."""

    # Default configuration values
    DEFAULTS = {
        'ABB_URL': 'http://audiobookbay.lu',
        'SCRAPE_INTERVAL': '60',
        'BIND_PROXY': '',
        'BASE_URL': '',
        'CIRCUIT_BREAKER_THRESHOLD': '3',
        'CIRCUIT_BREAKER_COOLDOWN': '300',
        'MAGNETS_DIR': 'data/magnets',
    }

    # Validation rules: (min, max) for integers, 'url' for URLs, 'proxy' for proxy URLs
    VALIDATORS = {
        'ABB_URL': 'url',
        'SCRAPE_INTERVAL': (15, 1440),
        'BIND_PROXY': 'proxy',
        'BASE_URL': 'url_optional',
        'CIRCUIT_BREAKER_THRESHOLD': (1, 10),
        'CIRCUIT_BREAKER_COOLDOWN': (60, 3600),
    }

    def __init__(self, config_path: str | None = None):
        """
        Initialize ConfigManager.

        Args:
            config_path: Path to config.env file. Defaults to /opt/bind/config.env
                         or ./config.env if running locally.
        """
        if config_path:
            self.config_path = config_path
        elif os.path.exists('/opt/bind/config.env'):
            self.config_path = '/opt/bind/config.env'
        else:
            # Local development fallback
            base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            self.config_path = os.path.join(base_dir, 'config.env')

    def read_config(self) -> dict:
        """
        Read configuration from config.env file.

        Returns:
            Dict of configuration values with defaults for missing keys.
        """
        config = self.DEFAULTS.copy()

        if not os.path.exists(self.config_path):
            return config

        try:
            with open(self.config_path, encoding='utf-8') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_SH)
                try:
                    for line in f:
                        line = line.strip()
                        # Skip comments and empty lines
                        if not line or line.startswith('#'):
                            continue
                        # Parse KEY=VALUE
                        if '=' in line:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = value.strip()
                            if key in self.DEFAULTS:
                                config[key] = value
                finally:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)
        except OSError as e:
            print(f"Warning: Could not read config file: {e}")

        return config

    def write_config(self, settings: dict) -> tuple[bool, str]:
        """
        Write configuration to config.env file.

        Args:
            settings: Dict of configuration values to save.

        Returns:
            Tuple of (success: bool, message: str)
        """
        # Validate all settings first
        for key, value in settings.items():
            if key in self.VALIDATORS:
                is_valid, error = self._validate(key, value)
                if not is_valid:
                    return False, error

        # Build config file content
        lines = [
            "# BIND Configuration",
            "# Generated by Web UI - Edit via http://YOUR-IP:5050/settings",
            "# Or edit manually and restart: systemctl restart bind",
            "",
        ]

        for key in self.DEFAULTS:
            value = settings.get(key, self.DEFAULTS[key])
            lines.append(f"{key}={value}")

        content = '\n'.join(lines) + '\n'

        try:
            with open(self.config_path, 'w', encoding='utf-8') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                try:
                    f.write(content)
                finally:
                    fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            return True, "Configuration saved successfully."
        except OSError as e:
            return False, f"Failed to write config: {e}"

    def _validate(self, key: str, value: str) -> tuple[bool, str]:
        """
        Validate a configuration value.

        Returns:
            Tuple of (is_valid: bool, error_message: str)
        """
        validator = self.VALIDATORS.get(key)

        if validator is None:
            return True, ""

        # Integer range validation
        if isinstance(validator, tuple):
            min_val, max_val = validator
            try:
                int_val = int(value)
                if int_val < min_val or int_val > max_val:
                    return False, f"{key} must be between {min_val} and {max_val}."
            except ValueError:
                return False, f"{key} must be a valid integer."
            return True, ""

        # URL validation
        if validator == 'url':
            if not value:
                return False, f"{key} cannot be empty."
            if not re.match(r'^https?://', value):
                return False, f"{key} must be a valid HTTP/HTTPS URL."
            return True, ""

        # Optional URL validation
        if validator == 'url_optional':
            if value and not re.match(r'^https?://', value):
                return False, f"{key} must be a valid HTTP/HTTPS URL or empty."
            return True, ""

        # Proxy validation (http, https, socks4, socks5)
        if validator == 'proxy':
            if value and not re.match(r'^(https?|socks[45])://', value):
                return False, f"{key} must be a valid proxy URL (http/https/socks4/socks5) or empty."
            return True, ""

        return True, ""

    def restart_daemon(self) -> tuple[bool, str]:
        """
        Restart the BIND daemon via systemctl.

        Returns:
            Tuple of (success: bool, message: str)
        """
        try:
            # Reload systemd to pick up any service file changes
            subprocess.run(
                ['systemctl', 'daemon-reload'],
                capture_output=True,
                timeout=10,
                check=False
            )

            # Restart the BIND service
            # Restart the BIND service
            subprocess.run(
                ['systemctl', 'restart', 'bind.service'],
                capture_output=True,
                timeout=30,
                check=True
            )
            return True, "Daemon restarted successfully."
        except subprocess.TimeoutExpired:
            return False, "Daemon restart timed out."
        except subprocess.CalledProcessError as e:
            stderr = e.stderr.decode('utf-8', errors='replace') if e.stderr else ''
            return False, f"Failed to restart daemon: {stderr}"
        except FileNotFoundError:
            return False, "systemctl not found. Running in development mode?"
